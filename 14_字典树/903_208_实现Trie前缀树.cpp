#include <stdio.h>
#include <queue>
#include <string>
#include <map>
#include <unordered_map>
#include <unordered_set>
#include <iostream>
using namespace std;

//Trie（发音类似 "try"）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。
//这一数据结构有相当多的应用情景，例如自动补全和拼写检查。
//
//请你实现 Trie 类：
//Trie() 初始化前缀树对象。
//void insert(String word) 向前缀树中插入字符串 word 。
//boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。
//boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。

//分析：将串中每个字符（26个小写字母）为结点，构造26叉树（其中包含大量空结点）。以数字索引访问结点，同时设计isEnd字段标记当前所在字符是否是单词的结尾

struct TrieNode {
    bool isEnd;
    vector<TrieNode*> children;
    TrieNode() : isEnd(false), children(26) {}//初始化26个nullptr孩子指针
};

class Trie {
private:
    TrieNode* root;
public:
    Trie() {
        root = new TrieNode();
    }

    void insert(string word) {
        TrieNode* pCur = root;
        int n = word.length();
        for (int i = 0;i < n;i++) {
            int ch = word[i] - 'a';
            if (!pCur->children[ch])//否则之前的某些串已经完成了该项构造
                pCur->children[ch] = new TrieNode();
            pCur = pCur->children[ch];
            if (i == n - 1)
                pCur->isEnd = true;
        }
    }

    bool search(string word) {
        TrieNode* pCur = root;
        int n = word.length();
        for (int i = 0;i < n;i++) {
            int ch = word[i] - 'a';
            if (!pCur->children[ch] )
                return false;
            pCur = pCur->children[ch];
            if (i == n - 1 && !pCur->isEnd)
                return false;
        }
            return true;
    }

    bool startsWith(string prefix) {
        TrieNode* pCur = root;
        int n = prefix.length();
        for (int i = 0;i < n;i++) {
            int ch = prefix[i] - 'a';
            if (!pCur->children[ch] )
                return false;
            pCur = pCur->children[ch];
        }
        return true;
    }
};